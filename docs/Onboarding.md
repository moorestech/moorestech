# moorestech アーキテクチャガイド

このドキュメントは、環境構築が完了したプログラマ向けのmoorestechアーキテクチャオンボーディングガイドです。システムの設計思想、コンポーネント間の依存関係、各レイヤーの責務を理解し、効率的に開発を進めるための知識を提供します。

もし分からないことがあれば、お手持ちのAIツールを利用する他、[DeepWiki](https://deepwiki.com/moorestech/moorestech) を利用できます。ただし、DeepWikiは2週間に1回程の更新であることに留意してください。

# アーキテクチャ概要

moorestechは完全分離型クライアント・サーバーアーキテクチャを採用した自動化工業ゲームです。

## サーバーの役割

サーバーはすべてのゲームロジックを管理します。ワールド内のブロック配置、アイテムの移動、クラフト処理など、ゲームの状態を一元的に保持し、処理します。サーバーが信頼できる唯一の情報源として機能します。将来的にマルチプレイヤー対応を行う予定です。

クライアントからのリクエストを受け取り、ゲームロジックを実行した結果をレスポンスとして返します。

## クライアントの役割

クライアントは表示とプレイヤー入力の処理のみを担当します。3Dオブジェクトの描画、UIの表示、カメラ制御、プレイヤーの操作入力をサーバーへ送信する役割を持ちます。クライアントにはゲームロジックを実装せず、サーバーから受け取った状態を忠実に表示することに徹します。（ただし、一部の例外はあります。）

これにより、サーバーとクライアントの実装を完全に分離し、保守性を向上させています。

## プロジェクト構成

```
moorestech/
├── moorestech_server/    # サーバー側（ゲームロジック、ワールド状態管理）
│   └── Assets/Scripts/
│       ├── Server.Boot/           # 起動・DI設定
│       ├── Server.Protocol/       # 通信層
│       ├── Game.World/            # ワールド・ブロック配置
│       ├── Game.Block/            # ブロック実装
│       ├── Game.Entity/           # エンティティ管理
│       ├── Game.PlayerInventory/  # プレイヤーインベントリ
│       ├── Game.Context/          # ゲームコンテキスト
│       └── Core.*/                # 基盤システム
│
├── moorestech_client/    # クライアント側（UI、描画、入力）
│   └── Assets/Scripts/
│       ├── Client.Starter/        # 起動・DI設定
│       ├── Client.Network/        # サーバー通信
│       ├── Client.Game/           # ゲーム状態
│       └── Client.Game.InGame.*/  # UI・表示
│
└── VanillaSchema/        # マスターデータスキーマ（YAML）
    ├── items.yml         # SourceGenerator入力
    ├── blocks.yml
    └── ...
```

## 共通アーキテクチャ

### DIコンテナ

初期化の際、DIコンテナを使って依存を解決します。クライアントはVContainer、サーバーはMicrosoft.Extensions.DependencyInjectionを使用しています。サーバーではコンストラクタインジェクションを、クライアントは[Inject]属性を使ったメソッド、フィールドインジェクションを行います。

DIコンテナは起動時に一度だけ構築され、その後はコンテナから必要なサービスを解決して使用します。

### ゲームコンテキスト

ServerContextやClientContextを利用して、よくアクセスするインスタンスに一発でアクセスできるようにしています。

頻繁に参照される主要なサービスやデータストアをコンテキストクラスにまとめることで、DIコンテナから毎回解決する手間を省き、コードの可読性を向上させています。

あるサービスをコンテキストに持たせるか否かについて厳密な判断基準はありませんが、アイテムやブロックといったゲーム全体に影響を与えるシステムはコンテキストで持つ方針です。コンテキストに持たせるかどうかは慎重な判断を伴います。

## Modサポート

TODO 追記
- moorestechはmodを強くサポートすることが開発しそうとしてあります。
- ゲームのマスターデータはJSONファイルとして全て外だしし、マスターデータと紐づくPrefabは全てAddressableから呼び出す。
- できるだけ拡張ポイントを持たせ、汎用的な実装をパラメーターを変えて使いまわせるような設計方針を目指している。

- 現在は1つのmodしか呼び出せず、コードの拡張も最低限しか行えない。将来的には複数のmodのマスターデータを呼び出し、多様なAPIを提供していきたいと思っている。

### マスターデータについて

MasterHolderから各種マスターデータをstaticアクセスで簡単に取得できるようにしています。MasterHolderの各要素が、マスターごとに便利にアクセスできるメソッドを提供しています。マスターデータはゲーム起動時に一度だけロードされ、実行中は不変のデータとして扱われます。

アイテム、ブロック、レシピ、チャレンジなど、あらゆるゲームコンテンツの定義情報がマスターデータとして管理されています。

TODO 追記
- blockId、ItemIdは動的に振られるもの。あくまで、その起動時のみのGUIDと対応付けられる。これはguidはデータ量が多いので、その場で仮のIDを付与しているという仕組み。
- mod構成が変わればblockIdと対応するGuidが変わるのでこの値は保存しない。そのため、アイテムやブロックを追加するmodについては、サーバーとクライアントで完全に同一でないとID間の不整合が生じる。


## マスターデータの定義、ロードシステム

moorestechのマスターデータは、YAML → C#自動生成 → JSON → 実行時ロードという4段階のプロセスで管理されます。

まず、VanillaSchema/配下のYAMLファイルでデータ構造を定義します。ここではテーブル名、カラム名、型、デフォルト値、主キーなどを宣言的に記述します。これがマスターデータのスキーマとなります。

次に、SourceGeneratorが動作し、YAMLファイルを読み込んでC#のデータクラスとローダークラスを自動生成します。生成されたコードはMooresmaster.Model.*という名前空間に配置され、開発者は手動でこれらのクラスを作成する必要がありません。

そして、modディレクトリのmaster配下のJSONファイルに実際のゲームデータを記述します。このJSONファイルは、自動生成されたスキーマに従った形式で記述する必要がありますが、mooreseditorという専用ツールを使うことで、JSONを触ることなく複雑なマスターデータを簡単に追加、編集することができます。
アイテム、ブロック、レシピ、その他ゲームのすべてのコンテンツがここに記述されます。

最後に、ゲーム起動時にJSONファイルを読み込み、MasterHolderに格納します。MasterHolderは静的クラスとして実装されており、ゲーム内のどこからでもマスターデータにアクセスできます。ItemMaster、BlockMaster、RecipeMasterなど、マスターデータの種類ごとに専用のアクセッサが用意されており、型安全にデータを取得できます。

この仕組みにより、プログラマはマスターデータの構造を定義するだけで、実際のデータ入力はデザイナーやプランナーに任せることができます。また、スキーマがコードとして表現されるため、型チェックが働き、データの不整合を早期に発見できます。

### UniRxの使用

プロジェクト全体としてUniRxを参照していますが、Rxは可読性やデータフローのトレーサビリティを下げるという思想のもと、必要な箇所にのみIObservableとSubjectを使用するのみにとどめています。
あくまでC#のeventを使いやすくするだけのライブラリとしてのみ使用しています。複雑なRxのオペレーターチェーンは避け、Subscribe、OnNext程度のシンプルな使い方に限定しています。

---

# サーバーアーキテクチャ

## 全体アーキテクチャ

サーバーは階層型アーキテクチャを採用しており、大きく分けてCore、Game、Serverの3つのレイヤーに分かれています。依存関係は常に上位から下位への一方向に制限されており、Coreが最下層の基盤システム、Gameがゲームロジック層、Serverが通信・起動層となります。

レイヤー構造：
```
Server (通信・起動)
  ↓ 依存
Game (ゲームロジック)
  ↓ 依存
Core (基盤システム)
```

## Coreの役割

Coreレイヤーは、ゲーム全体で共通して使用される基盤システムを提供します。アイテムの基本データ構造（Core.Item）、インベントリの操作ロジック（Core.Inventory）、マスターデータの管理（Core.Master）、ゲームのティックシステム（Core.Update）など、他のすべてのレイヤーが依存する土台となる機能を実装しています。

Coreレイヤーの特徴は、ゲームの各要素固有のロジックを持たず、汎用的な処理を提供します。。例えば、Core.Inventoryはスロットベースのインベントリ操作を提供しますが、ブロックやプレイヤーといった具体的なゲーム要素には依存しません。

## Gameの役割

Gameレイヤーは、ゲームの各要素固有のロジックを実装します。ワールド内のブロック管理（Game.World）、個別のブロック実装（Game.Block）、エンティティの振る舞い（Game.Entity）、プレイヤーのインベントリ管理（Game.PlayerInventory）など、moorestechのゲームルールと動作を定義します。

Gameレイヤーは、Coreレイヤーが提供する基盤機能を組み合わせて、具体的なゲーム体験を構築します。例えば、Game.BlockではCore.Inventoryのインターフェースを利用してブロックのアイテム保管機能を実装したり、Game.EnergySystemでは電力ネットワークの構築や電力供給の処理を行っています。

また、先述のServerContextはGame.Contextの中にあり、各種サービスへのアクセスを容易にしています。

## Serverの役割

Serverレイヤーは、サーバーの起動処理と、クライアントとの通信を担当します。Server.Bootではアプリケーションのエントリーポイントとして、DIコンテナの構築、マスターデータのロード、ワールドの初期化、MODシステムの起動を順番に実行します。
Server.Protocolでは、クライアントからのリクエストを受け取り、適切なゲームロジックを呼び出し、結果をレスポンスとして返します。

Serverレイヤーの重要な責務は、クライアントとGameレイヤーの間の橋渡しをすることです。プロトコルハンドラーがクライアントからのリクエストを受け取り、それを適切なGameレイヤーのサービスに委譲します。また、ゲーム内で発生したイベントをクライアントに通知するイベントシステムも、Serverレイヤーで管理されています。

### プロトコルの設計思想

moorestechのプロトコルは以下の3つの原則に基づいて設計されています。

第一に、ステートレス設計です。各リクエストは独立しており、サーバーはクライアントのセッション状態を保持しません。すべての必要な情報はリクエストに含まれており、サーバーは前回のリクエストを覚えている必要がありません。これにより、サーバーの実装がシンプルになり、スケーラビリティが向上します。

第二に、クライアント主導の通信です。クライアントからリクエストが来て、初めてサーバーがデータを返したりサーバーの状態を変更したりします。サーバーから能動的にデータを送ることはありません。これにより、クライアントが通信のタイミングを完全に制御できるほか、サーバーの実装をシンプルに保つことができます。

第三に、MessagePackを利用したバイナリシリアライゼーションです。高パフォーマンス、低容量、型安全性というメリットがあり、プロトコルのリクエスト、レスポンス定義がC#のクラスとして明示的に表現されています。

### サーバーイベントシステムについて

moorestechはクライアント主導の通信を採用していますが、サーバー側で起きたことをクライアントに伝えたいケースが存在します。例えば、ブロックの内部状態の更新や、他のプレイヤーのアクションによる変化などです。これを実現するために、イベントシステムという仕組みを採用しています。

イベントシステムでは、クライアント側の責務でイベントリクエストパケットを定期的にポーリングします。サーバー側は各ユーザーごとにイベントキューを保持しており、ゲーム内で何か変化が発生したときに、該当するユーザーのキューにイベントを追加します。クライアントからイベントのリクエストが来た時に、サーバーは溜めておいたイベントをまとめて返します。

このアーキテクチャにより、サーバーからの能動的な通信を避けつつ、リアルタイムにゲーム状態の変更をクライアントに伝えることができます。クライアントはポーリング頻度を調整することで、ネットワーク負荷とリアルタイム性のバランスを取ることができます。また、イベントをキューに溜めることで、ネットワークの一時的な切断にも対応できます。

## サーバーの初期化

サーバーの初期化は、Server.Boot配下のブートクラスで管理されます。初期化プロセスは以下の順序で実行されます。

指摘：順番が違います。もう一度Server.Boot内の処理をよくみて書き直してください。

まず、DIコンテナの構築を行います。Microsoft.Extensions.DependencyInjectionを使用して、すべてのサービスをコンテナに登録します。この段階で、各サービスのライフタイム（Singleton、Scoped、Transient）が決定され、依存関係のグラフが構築されます。

次に、マスターデータのロードを行います。VanillaSchemaから生成されたローダークラスを使用して、mods/vanilla/master/配下のJSONファイルを読み込み、MasterHolderに格納します。マスターデータはゲーム実行中は不変なので、この時点で一度だけロードされます。

続いて、ワールドの初期化を行います。新規ワールドの場合は初期状態を生成し、既存ワールドの場合はセーブデータから復元します。ワールドの初期化が完了すると、ブロックやエンティティが配置され、ゲームが実行可能な状態になります。

最後に、MODシステムの起動を行います。各MODのエントリーポイントが呼び出され、MODが追加する機能やコンテンツが登録されます。すべての初期化が完了すると、サーバーはクライアントからの接続を受け付ける準備が整います。

## セーブ、ロードシステム

moorestechのセーブ・ロードシステムは、ゲーム状態を完全に保存・復元できるように設計されています。重要な設計原則は、ロード時にイベントを発行しないことです。

セーブ時には、各ゲームオブジェクトが自身の状態をシリアライズ可能な形式に変換します。例えばブロックはその位置、種類、内部状態（インベントリの内容、進行中のクラフトなど）を保存します。プレイヤーに関連する情報も、プレイヤーインベントリや最後にいた座標を保持します。これらの情報はすべてJSONファイルに書き出されます。

ロード時には、保存されたデータから各ゲームオブジェクトを復元します。ここで重要なのは、通常の状態変更メソッド（SetItemなど）を使わないことです。これらのメソッドはイベントを発行するため、ロード時に大量のイベントが発行され、意図しない副作用が発生する可能性があります。

そのため、ロード専用のコンストラクタやファクトリメソッドを用意し、イベントを発行せずに直接状態を設定します。すべてのオブジェクトの復元が完了した後、初めてゲームのティックが開始され、通常の動作が再開されます。この設計により、セーブ・ロードの信頼性が確保され、ゲーム状態の完全な復元が可能になります。

指摘 TODO 以下を追記
- 保存しない情報について
- クライアントとのやりとりにのみ使用する情報（ItemInstanceId）
- マスターデータのセクションにも書いてあるが、blockIdやitemIdといったint型ベースのIDはmod構成によって変化するので保存しない。これらの情報は全てGUIDに変換して保存する。
- ブロック間のインベントリ同士のつながりや、電力ネットワークのつながりといった、各要素間のつながりが決定論的に決まるものは保存しない。これは保存データ設計の簡略化と、システムやマスターデータに変化が生じた際に極力不整合が生じないようにするため。例えば、「電力のつながり」という状態を保存して、「電柱が機械と接続できる範囲」が小さくなった時、小さくする前のデータをロードすると本来繋がるべきでない場所同士の電柱が接続されてしまう。

## テストの作成

サーバー側のテストは、Tests.Module配下に配置されます。テストはNUnit形式で記述され、Unity Test Frameworkを使用して実行されます。

テストコードを書く際は、テスト用のマスターデータ（Tests.Module/TestMod/ForUnitTest/）を使用します。本番環境のマスターデータは複雑で大量のため、テストでは必要最小限の定義だけを含むテスト用データを用意します。

- テストは特定の処理を検証するユニットテストと、複数のモジュールを統合的に繋げてテストする結合テストを記述する。
- ブロックの単一機能のテストでも、ServerContextに依存している関係上、通常の起動フローと同じ初期化を行う必要がある。その際は 

```cs
var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(new MoorestechServerDIContainerOptions(TestModDirectory.ForUnitTestModDirectory));
```

を呼び出す。ほぼ全てのテストにおいてこれを呼び出しています。

---

# クライアントアーキテクチャ

## 全体アーキテクチャ

クライアントは、サーバーと同様に階層型アーキテクチャを採用していますが、サーバーとは異なる構造を持ちます。クライアントの主要なレイヤーは、Starter（起動）、Network（通信）、Game（状態管理）、InGame（UI・表示）の4つです。

レイヤー構造：
```
Client.Starter (起動・DI設定)
  ↓
Client.Network (サーバー通信)
  ↓
Client.Game (クライアント側状態管理)
  ↓
Client.Game.InGame.* (UI・表示)
```

Client.Starterはアプリケーションのエントリーポイントとして、VContainerのセットアップとシーンの初期化を行います。Client.Networkはサーバーとの通信を担当し、リクエストの送信とイベントの受信を管理します。Client.Gameはサーバーから受け取った状態をクライアント側で保持し、UIや表示への変更通知を行います。Client.Game.InGame.*は、実際の3D表示やUIの描画、プレイヤーの入力処理を担当します。

クライアントの設計で重要なのは、クライアント側にゲームロジックを持たないことです。すべてのゲームルールはサーバーで実行され、クライアントはその結果を表示するだけです。ただし、レスポンス性を向上させるために、楽観的更新（Optimistic Update）という手法を部分的に採用しています。

TODO 指摘
- 依存関係はNetwork ← Gameです。また、Gameとしての処理は存在しません。GameとInGameはほぼ同一です。そのため、ここからClient.Gameについての項目を削除してください。

## Networkの役割

Client.Networkレイヤーは、サーバーとの通信を一手に引き受けます。主な責務は、クライアントからのリクエスト送信と、サーバーからのイベント受信です。

リクエスト送信は、VanillaApiSendOnlyクラス、VanillaApiWithResponseクラスが担当します。
TODO それぞれの実装を見てこの続きを簡単に書く。

イベント受信は、EventProtocolReceiverクラスが管理します。定期的にサーバーにイベントリクエストを送信し、サーバーが溜めているイベントを受け取ります。受信したイベントは、IObservableを通じて購読者に通知されます。これにより、サーバー側の状態変更がクライアントに伝播し、UIや表示が更新されます。

通信層では、接続の確立、切断、データのパース、各リクエストを適切に処理するためのシーケンス管理の処理も行います。

## InGameの役割

Client.Game.InGameレイヤーは、実際のゲーム画面の表示とプレイヤーの入力処理を担当します。このレイヤーは、他のレイヤーと異なり、複雑な相互依存関係を持つことが許容されています。

そもそも、ゲームの仕様として、InGameは各要素間が複雑に絡み合います。例えば、ブロックの配置はインベントリの状態に依存し、ブロック内のインベントリ操作はプレイヤーのインベントリにも影響を与え、ブロックの開閉にはプレイヤーの距離が関わってきます。
そのため、大まかに上位レイヤーっぽい動きをするもの（UIState）や、各要素の詳細レイヤーを実装するものという区分けがありますが、実装速度や、下手に分離してデータフローがわかりづらくなるよりかは、アセンブリを分けず、素直に参照することにしています。

また、各モジュール間のSerializeFieldをなるべく避け、Injectによって注入することにより、ゆるく循環参照を避けるようなアーキテクチャをとっています。SerializeFieldは容易に循環参照になる一方、Injectを使うことでDIが失敗し循環参照を避けることができます。
これは厳密なコード規約ではなく、あくまで複雑な仕様の中で品質を保つ基本方針です。


## Skitの役割

Client.Skitレイヤーは、ゲーム内のスキット（会話・イベントシーン）システムを担当します。スキットは、ストーリーの進行やチュートリアル、キャラクター間の会話などを表現するための機能です。

Skitシステムは、独自のスクリプト形式でシーンを記述し、それを解釈して実行します。テキストの表示、キャラクターの立ち絵の表示、選択肢の提示、フラグの設定など、ビジュアルノベル風の演出が可能です。

Skitレイヤーは、InGameレイヤーから独立しており、スキット専用のUIとロジックを持ちます。これにより、通常のゲームプレイとスキットシステムが互いに干渉せず、それぞれを独立して開発・テストできます。
スキットの内容はjsonファイルとして外部ファイルで管理されており、専用ツールでプログラマ以外でもスキットを作成・編集できるようになっています。
