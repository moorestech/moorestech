# moorestech アーキテクチャガイド

このドキュメントは、環境構築が完了したプログラマ向けのmoorestechアーキテクチャオンボーディングガイドです。システムの設計思想、コンポーネント間の依存関係、各レイヤーの責務を理解し、効率的に開発を進めるための知識を提供します。

もし分からないことがあれば、お手持ちのAIツールを利用する他、[DeepWiki](https://deepwiki.com/moorestech/moorestech) を利用できます。ただし、DeepWikiは2週間に1回程の更新であることに留意してください。

# アーキテクチャ概要

moorestechはクライアント・サーバーアーキテクチャを採用した自動化工業ゲームです。

## サーバーの役割

サーバーはすべてのゲームロジックを管理します。ワールド内のブロック配置、アイテムの移動、クラフト処理など、ゲームの状態を一元的に保持し、処理します。サーバーが信頼できる唯一の情報源として機能します。将来的にマルチプレイヤー対応を行う予定です。

クライアントからのリクエストを受け取り、ゲームロジックを実行した結果をレスポンスとして返します。

## クライアントの役割

クライアントは表示とプレイヤー入力の処理のみを担当します。3Dオブジェクトの描画、UIの表示、カメラ制御、プレイヤーの操作入力をサーバーへ送信する役割を持ちます。クライアントにはゲームロジックを実装せず、サーバーから受け取った状態を忠実に表示することに徹します。（ただし、一部の例外はあります。）

これにより、サーバーとクライアントの実装を完全に分離し、保守性を向上させています。

## プロジェクト構成

```
moorestech/
├── moorestech_server/    # サーバー側（ゲームロジック、ワールド状態管理）
│   └── Assets/Scripts/
│       ├── Server.Boot/           # 起動・DI設定
│       ├── Server.Protocol/       # 通信層
│       ├── Game.World/            # ワールド・ブロック配置
│       ├── Game.Block/            # ブロック実装
│       ├── Game.PlayerInventory/  # プレイヤーインベントリ
│       ├── Game.Context/          # ゲームコンテキスト
│       └── Core.*/                # 基盤システム
│
├── moorestech_client/    # クライアント側（UI、描画、入力）
│   └── Assets/Scripts/
│       ├── Client.Starter/        # 起動・DI設定
│       ├── Client.Network/        # サーバー通信
│       └── Client.Game/           # 3D表示、操作、UI
│
└── VanillaSchema/        # マスターデータスキーマ（YAML）
    ├── items.yml         # SourceGenerator入力
    ├── blocks.yml
    └── ...
```

## 共通アーキテクチャ

### DIコンテナ

初期化の際、DIコンテナを使って依存を解決します。クライアントはVContainer、サーバーはMicrosoft.Extensions.DependencyInjectionを使用しています。サーバーではコンストラクタインジェクションを、クライアントは[Inject]属性を使ったメソッド、フィールドインジェクションを行います。

DIコンテナは起動時に一度だけ構築され、その後はコンテナから必要なサービスを解決して使用します。

### ゲームコンテキスト

ServerContextやClientContextを利用して、よくアクセスするインスタンスに一発でアクセスできるようにしています。

頻繁に参照される主要なサービスやデータストアをコンテキストクラスにまとめることで、DIコンテナから毎回解決する手間を省き、コードの可読性を向上させています。

あるサービスをコンテキストに持たせるか否かについて厳密な判断基準はありませんが、アイテムやブロックといったゲーム全体に影響を与えるシステムはコンテキストで持つ方針です。コンテキストに持たせるかどうかは慎重な判断を伴います。

## Modサポート

moorestechはmodを強くサポートすることを目指して開発されています。ゲームのマスターデータはJSONファイルとして全て外部化され、マスターデータと紐づくPrefabやアセットは全てAddressableから呼び出す設計になっています。これにより、プログラマ以外でもゲームコンテンツの追加や変更が可能になります。

また、できるだけ拡張ポイントを持たせ、汎用的な実装をパラメーターを変えて使いまわせるような設計方針を採用しています。例えば、ブロックの振る舞いは可能な限りマスターデータのパラメータで制御でき、同じコードベースで多様なブロックを実現できるようになっています。

現在は1つのmodしか呼び出せず、dllロードやコードの拡張も最低限しか行えない状態ですが、将来的には複数のmodのマスターデータを統合して呼び出し、modが独自のゲームロジックを追加できるような多様なAPIを提供していく予定です。

### マスターデータについて

MasterHolderから各種マスターデータをstaticアクセスで簡単に取得できるようにしています。MasterHolderの各要素が、マスターごとに便利にアクセスできるメソッドを提供しています。マスターデータはゲーム起動時に一度だけロードされ、実行中は不変のデータとして扱われます。

アイテム、ブロック、レシピ、チャレンジなど、あらゆるゲームコンテンツの定義情報がマスターデータとして管理されています。

重要な実装の詳細として、BlockIdやItemIdといったUnitGeneratorを使用したintのIDは実行時に動的に振られるIDです。これらのIDは、起動時にマスターデータに定義された各要素のGUID（文字列）と対応付けられる形で生成されます。GUIDはデータ量が多く、パフォーマンスや通信量に影響を与えるため、内部的にはint型の仮IDを使用するという仕組みです。

そのため、mod構成が変わればBlockIdやItemIdと対応するGUIDが変化する可能性があるため、これらの値はセーブデータに保存しません。保存時にはGUIDに変換し、ロード時に再度その時点でのIDに変換します。このため、アイテムやブロック等を追加するmodについては、サーバーとクライアントで完全に同一の構成でないとID間の不整合が生じる点に注意が必要です。


## マスターデータの定義、ロードシステム

moorestechのマスターデータは、YAML → C#自動生成 → JSON → 実行時ロードという4段階のプロセスで管理されます。

まず、VanillaSchema/配下のYAMLファイルでデータ構造を定義します。ここではテーブル名、カラム名、型、デフォルト値、主キーなどを宣言的に記述します。これがマスターデータのスキーマとなります。

次に、SourceGeneratorが動作し、YAMLファイルを読み込んでC#のデータクラスとローダークラスを自動生成します。生成されたコードはMooresmaster.Model.*という名前空間に配置され、開発者は手動でこれらのクラスを作成する必要がありません。

そして、modディレクトリのmaster配下のJSONファイルに実際のゲームデータを記述します。このJSONファイルは、自動生成されたスキーマに従った形式で記述する必要がありますが、mooreseditorという専用ツールを使うことで、JSONを触ることなく複雑なマスターデータを簡単に追加、編集することができます。
アイテム、ブロック、レシピ、その他ゲームのすべてのコンテンツがここに記述されます。

最後に、ゲーム起動時にJSONファイルを読み込み、MasterHolderに格納します。MasterHolderは静的クラスとして実装されており、ゲーム内のどこからでもマスターデータにアクセスできます。ItemMaster、BlockMaster、RecipeMasterなど、マスターデータの種類ごとに専用のアクセッサが用意されており、型安全にデータを取得できます。

この仕組みにより、プログラマはマスターデータの構造を定義するだけで、実際のデータ入力はデザイナーやプランナーに任せることができます。また、スキーマがコードとして表現されるため、型チェックが働き、データの不整合を早期に発見できます。

### UniRxの使用

プロジェクト全体としてUniRxを参照していますが、Rxは可読性やデータフローのトレーサビリティを下げるという思想のもと、必要な箇所にのみIObservableとSubjectを使用するのみにとどめています。
あくまでC#のeventを使いやすくするだけのライブラリとしてのみ使用しています。複雑なRxのオペレーターチェーンは避け、Subscribe、OnNext程度のシンプルな使い方に限定しています。

---

# サーバーアーキテクチャ

## 全体アーキテクチャ

サーバーは階層型アーキテクチャを採用しており、大きく分けてCore、Game、Serverの3つのレイヤーに分かれています。依存関係は常に上位から下位への一方向に制限されており、Coreが最下層の基盤システム、Gameがゲームロジック層、Serverが通信・起動層となります。

レイヤー構造：
```
Server (通信・起動)
  ↓ 依存
Game (ゲームロジック)
  ↓ 依存
Core (基盤システム)
```

## Coreの役割

Coreレイヤーは、ゲーム全体で共通して使用される基盤システムを提供します。アイテムの基本データ構造（Core.Item）、インベントリの操作ロジック（Core.Inventory）、マスターデータの管理（Core.Master）、ゲームのティックシステム（Core.Update）など、他のすべてのレイヤーが依存する土台となる機能を実装しています。

Coreレイヤーの特徴は、ゲームの各要素固有のロジックを持たず、汎用的な処理を提供することです。例えば、Core.Inventoryはスロットベースのインベントリ操作を提供しますが、ブロックやプレイヤーといった具体的なゲーム要素には依存しません。

## Gameの役割

Gameレイヤーは、ゲームの各要素固有のロジックを実装します。ワールド内のブロック管理（Game.World）、個別のブロック実装（Game.Block）、エンティティの振る舞い（Game.Entity）、プレイヤーのインベントリ管理（Game.PlayerInventory）など、moorestechのゲームルールと動作を定義します。

Gameレイヤーは、Coreレイヤーが提供する基盤機能を組み合わせて、具体的なゲーム体験を構築します。例えば、Game.BlockではCore.Inventoryのインターフェースを利用してブロックのアイテム保管機能を実装したり、Game.EnergySystemでは電力ネットワークの構築や電力供給の処理を行っています。

また、先述のServerContextはGame.Contextの中にあり、各種サービスへのアクセスを容易にしています。

## Serverの役割

Serverレイヤーは、サーバーの起動処理と、クライアントとの通信を担当します。Server.Bootではアプリケーションのエントリーポイントとして、DIコンテナの構築、マスターデータのロード、ワールドの初期化、MODシステムの起動を順番に実行します。
Server.Protocolでは、クライアントからのリクエストを受け取り、適切なゲームロジックを呼び出し、結果をレスポンスとして返します。

Serverレイヤーの重要な責務は、クライアントとGameレイヤーの間の橋渡しをすることです。プロトコルハンドラーがクライアントからのリクエストを受け取り、それを適切なGameレイヤーのサービスに委譲します。また、ゲーム内で発生したイベントをクライアントに通知するイベントシステムも、Serverレイヤーで管理されています。

### プロトコルの設計思想

moorestechのプロトコルは以下の3つの原則に基づいて設計されています。

第一に、ステートレス設計です。各リクエストは独立しており、サーバーはクライアントのセッション状態を保持しません。すべての必要な情報はリクエストに含まれており、サーバーは前回のリクエストを覚えている必要がありません。これにより、サーバーの実装がシンプルになり、スケーラビリティが向上します。

第二に、クライアント主導の通信です。クライアントからリクエストが来て、初めてサーバーがデータを返したりサーバーの状態を変更したりします。サーバーから能動的にデータを送ることはありません。これにより、クライアントが通信のタイミングを完全に制御できるほか、サーバーの実装をシンプルに保つことができます。

第三に、MessagePackを利用したバイナリシリアライゼーションです。高パフォーマンス、低容量、型安全性というメリットがあり、プロトコルのリクエスト、レスポンス定義がC#のクラスとして明示的に表現されています。

### サーバーイベントシステムについて

moorestechはクライアント主導の通信を採用していますが、サーバー側で起きたことをクライアントに伝えたいケースが存在します。例えば、ブロックの内部状態の更新や、他のプレイヤーのアクションによる変化などです。これを実現するために、イベントシステムという仕組みを採用しています。

イベントシステムでは、クライアント側の責務でイベントリクエストパケットを定期的にポーリングします。サーバー側は各ユーザーごとにイベントキューを保持しており、ゲーム内で何か変化が発生したときに、該当するユーザーのキューにイベントを追加します。クライアントからイベントのリクエストが来た時に、サーバーは溜めておいたイベントをまとめて返します。

このアーキテクチャにより、サーバーからの能動的な通信を避けつつ、リアルタイムにゲーム状態の変更をクライアントに伝えることができます。クライアントはポーリング頻度を調整することで、ネットワーク負荷とリアルタイム性のバランスを取ることができます。また、イベントをキューに溜めることで、ネットワークの一時的な切断にも対応できます。

## サーバーの初期化

サーバーの初期化は、Server.Boot配下のブートクラスで管理されます。初期化プロセスは以下の順序で実行されます。

まず、マスターデータのロードを行います。VanillaSchemaから生成されたローダークラスを使用して、modsディレクトリ配下のJSONファイルを読み込み、MasterHolderに格納します。マスターデータはゲーム実行中は不変なので、この時点で一度だけロードされます。マスターデータはDIコンテナ構築時に各サービスが参照する可能性があるため、最初にロードする必要があります。

次に、ServerContext専用のDIコンテナを構築し、ServerContextに必要なインスタンスの解決を行います。ServerContextは頻繁にアクセスされる主要なサービスをまとめて保持するクラスであり、これらのサービスを先に初期化しておく必要があります。この段階で、ServerContextが依存するコアサービス群がインスタンス化されます。

続いて、メインのDIコンテナの構築を行います。Microsoft.Extensions.DependencyInjectionを使用して、すべてのサービスをコンテナに登録します。この段階で、各サービスのライフタイム（Singleton、Scoped、Transient）が決定され、依存関係のグラフが構築されます。

続いて、ワールドの初期化を行います。新規ワールドの場合は初期状態を生成し、既存ワールドの場合はセーブデータから復元します。ワールドの初期化が完了すると、ブロックやエンティティが配置され、ゲームが実行可能な状態になります。

最後に、プロトコルサーバーの起動とクライアント接続の受付を開始します。すべての初期化が完了すると、サーバーはクライアントからのリクエストを処理できる状態になります。

## セーブ、ロードシステム

moorestechのセーブ・ロードシステムは、ゲーム状態を完全に保存・復元できるように設計されています。重要な設計原則は、ロード時にイベントを発行しないことです。

セーブ時には、各ゲームオブジェクトが自身の状態をシリアライズ可能な形式に変換します。例えばブロックはその位置、種類、内部状態（インベントリの内容、進行中のクラフトなど）を保存します。プレイヤーに関連する情報も、プレイヤーインベントリや最後にいた座標を保持します。これらの情報はすべてJSONファイルに書き出されます。

ロード時には、保存されたデータから各ゲームオブジェクトを復元します。ここで重要なのは、通常の状態変更メソッド（SetItemなど）を使わないことです。これらのメソッドはイベントを発行するため、ロード時に大量のイベントが発行され、意図しない副作用が発生する可能性があります。

そのため、ロード専用のコンストラクタやファクトリメソッドを用意し、イベントを発行せずに直接状態を設定します。すべてのオブジェクトの復元が完了した後、初めてゲームのティックが開始され、通常の動作が再開されます。この設計により、セーブ・ロードの信頼性が確保され、ゲーム状態の完全な復元が可能になります。

### 保存しない情報について

セーブシステムでは、すべての情報を保存するわけではありません。以下の情報は意図的に保存していません。

まず、クライアントとのやりとりにのみ使用する一時的な情報は保存しません。例えば、ItemInstanceIdはクライアントがアイテムの移動をトラッキングするために使用しますが、サーバー側の永続的な状態には関係ないため保存対象外です。

次に、マスターデータのセクションでも説明したとおり、blockIdやitemIdといったint型ベースのIDはmod構成によって変化するため保存しません。これらの情報は全てGUID（文字列）に変換して保存し、ロード時に再度その時点でのIDに変換されます。

最後に、ブロック間のインベントリ同士のつながりや、電力ネットワークのつながりといった、各要素間のつながりで決定論的に決まるものは保存しません。これは保存データ設計の簡略化と、システムやマスターデータに変化が生じた際に極力不整合が生じないようにするためです。例えば、「電力のつながり」という状態を保存した場合、マスターデータで「電柱が機械と接続できる範囲」が小さくなったときに、古いデータをロードすると本来繋がるべきでない場所同士の電柱が接続されてしまいます。これらの接続関係は、ロード時にその時点でのルールに基づいて再計算されます。

## テストの作成

サーバー側のテストは、Tests.Module配下に配置されます。テストはNUnit形式で記述され、Unity Test Frameworkを使用して実行されます。

テストコードを書く際は、テスト用のマスターデータ（Tests.Module/TestMod/ForUnitTest/）を使用します。本番環境のマスターデータは複雑で大量のため、テストでは必要最小限の定義だけを含むテスト用データを用意します。

テストは特定の処理を検証するユニットテストと、複数のモジュールを統合的に繋げてテストする結合テストを記述します。ブロックの単一機能のテストでも、ServerContextに依存している関係上、通常の起動フローと同じ初期化を行う必要があります。その際は以下のコードを呼び出します。

```cs
var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(new MoorestechServerDIContainerOptions(TestModDirectory.ForUnitTestModDirectory));
```

このDIコンテナ生成処理は、ほぼ全てのテストにおいて呼び出しています。

---

# クライアントアーキテクチャ

## 全体アーキテクチャ

クライアントは、サーバーと同様に階層型アーキテクチャを採用していますが、サーバーとは異なる構造を持ちます。クライアントの主要なレイヤーは、Starter（起動）、Network（通信）、InGame（UI・表示）の3つです。

レイヤー構造：
```
Client.Starter (起動・DI設定)
  ↓     ↓
  ↓  Client.Network (サーバー通信)
  ↓     ↑
Client.Game.InGame.* (UI・表示)
```

依存関係はInGame → Networkの順です。Client.Starterはアプリケーションのエントリーポイントとして、VContainerのセットアップとシーンの初期化を行います。Client.Networkはサーバーとの通信を担当し、リクエストの送信とイベントの受信を管理します。Client.Game.InGame.*は、実際の3D表示やUIの描画、プレイヤーの入力処理を担当します。

クライアントの設計で重要なのは、クライアント側にゲームロジックを持たないことです。すべてのゲームルールはサーバーで実行され、クライアントはその結果を表示するだけです。

## Networkの役割

Client.Networkレイヤーは、サーバーとの通信を一手に引き受けます。主な責務は、クライアントからのリクエスト送信と、サーバーからのイベント受信です。

リクエスト送信は、VanillaApiSendOnlyクラスとVanillaApiWithResponseクラスが担当します。VanillaApiSendOnlyは、サーバーにリクエストを送信するだけで、レスポンスを待ちません。ブロックの配置やアイテムの移動など、レスポンスを待つ必要がない操作に使用されます。一方、VanillaApiWithResponseは、リクエストを送信してレスポンスを受け取り、そのデータを処理します。ワールド情報の取得など、サーバーからのデータが必要な場合に使用されます。

イベント受信は、EventProtocolReceiverクラスが管理します。定期的にサーバーにイベントリクエストを送信し、サーバーが溜めているイベントを受け取ります。受信したイベントは、IObservableを通じて購読者に通知されます。これにより、サーバー側の状態変更がクライアントに伝播し、UIや表示が更新されます。

通信層では、接続の確立、切断、データのパース、各リクエストを適切に処理するためのシーケンス管理の処理も行います。

## InGameの役割

Client.Game.InGameレイヤーは、実際のゲーム画面の表示とプレイヤーの入力処理を担当します。このレイヤーは、他のレイヤーと異なり、複雑な相互依存関係を持つことが許容されています。

そもそも、ゲームの仕様として、InGameは各要素間が複雑に絡み合います。例えば、ブロックの配置はインベントリの状態に依存し、ブロック内のインベントリ操作はプレイヤーのインベントリにも影響を与え、ブロックの開閉にはプレイヤーの距離が関わってきます。

そのため、大まかに上位レイヤーっぽい動きをするもの（UIState）や、各要素の詳細レイヤーを実装するものという区分けはあります。これを下手にinterfaceを切ったり、イベント駆動で厳密に分離すると、かえってデータフローが複雑になり、可読性や保守性を下げると判断しました。そのためここではアセンブリを分けず、素直にクラスを参照する方針で実装を進めています。

また、各モジュール間のSerializeFieldをなるべく避け、Injectによって注入することにより、ゆるく循環参照を避けるようなアーキテクチャをとっています。SerializeFieldは容易に循環参照になる一方、Injectを使うことでDIが失敗し循環参照を避けることができます。
これは厳密なコード規約ではなく、あくまで複雑な仕様の中で品質を保つ基本方針です。


## Skitの役割

Client.Skitレイヤーは、ゲーム内のスキット（会話・イベントシーン）システムを担当します。スキットは、ストーリーの進行やチュートリアル、キャラクター間の会話などを表現するための機能です。

Skitシステムは、独自のスクリプト形式でシーンを記述し、それを解釈して実行します。テキストの表示、キャラクターの立ち絵の表示、選択肢の提示、フラグの設定など、ビジュアルノベル風の演出が可能です。

Skitレイヤーは、InGameレイヤーから独立しており、スキット専用のUIとロジックを持ちます。これにより、通常のゲームプレイとスキットシステムが互いに干渉せず、それぞれを独立して開発・テストできます。
スキットの内容はjsonファイルとして外部ファイルで管理されており、専用ツールでプログラマ以外でもスキットを作成・編集できるようになっています。
