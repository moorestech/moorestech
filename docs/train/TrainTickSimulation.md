# Train Tick Simulation

## Deterministic tick rationale
Train simulation is executed on a deterministic fixed-step timeline so that server-side decisions are reproducible in tests and across multiplayer sessions. A fixed tick gives us predictable travel distance, makes arrival order and docking outcomes independent of the rendering frame-rate, and lets save/load or rollback logic rewind to exact train states. Deterministic ticks also ensure that schedule automation (for example, `TrainDiagram`) only departs after all blocks observing a docking tick have consumed their turn, avoiding subtle race conditions between stations and train state machines.

## Tick length and scheduling
The train loop runs at 120 Hz, i.e. each simulation tick advances by \(1/120\) seconds (~8.33 ms). Keeping the tick length short aligns rail motion with fast conveyor throughput while still leaving enough headroom for server updates. The tick duration is sourced from the same `GameUpdater.UpdateSecondTime` value that the rest of the simulation uses, so integration tests can drive the system by calling `GameUpdater.SpecifiedDeltaTimeUpdate(1.0 / 120.0)` or multiples thereof. Any wall-clock delta from `GameUpdater.UpdateObservable` is accumulated, then processed in deterministic quanta, ensuring that a long frame simply enqueues several 120 Hz ticks instead of stretching movement.

## `TrainUpdateService` accumulation loop
`TrainUpdateService` subscribes to the global `GameUpdater.UpdateObservable` so that it is invoked once per server frame.【F:moorestech_server/Assets/Scripts/Game.Train/Common/TrainUpdateService.cs†L26-L38】 Internally the service maintains an `_accumulatedSeconds` buffer: each update adds the latest `GameUpdater.UpdateSecondTime`, then while the buffer is greater than or equal to the 1/120 s tick it repeatedly calls `AdvanceOneTick` on every registered `TrainUnit` and subtracts the tick duration. Any remainder is left in `_accumulatedSeconds`, guaranteeing that the next frame begins exactly where the prior tick stopped. Because all trains are stepped inside the same `while` loop, every train consumes the same number of ticks before the service returns, preserving ordering guarantees even when multiple catch-up ticks are required.

The deterministic contract relies on game code never skipping a queued tick. If the server is paused (for example during save/load), callers should suspend the subscription or zero the accumulator to avoid replaying stale time slices when resuming.

## Fixed-point travel distance
All rail graph distances are stored as integers. `RailComponent.ConnectRailComponent` rounds the Bézier length of the segment to an `int` before creating the node-to-node edge, and `RailNode` keeps that integer as the canonical distance. This fixed-point representation means the tick loop only ever consumes whole units during `UpdateTrainByDistance`, so the same number of ticks always leads to the same node index regardless of floating-point drift.

Any fractional progress generated by the physics integrator remains inside `UpdateTrainByTime`, which accumulates a float distance and truncates it deterministically via `Math.Truncate`, feeding only the integer part to `UpdateTrainByDistance`.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L123-L137】 Because the saved `RailPosition` snapshot only contains integer distances, saving mid-run and reloading will resume at exactly the same node/offset pair; there is no need for epsilon comparisons when reversing direction or docking.

## `TrainUnit.AdvanceOneTick` control flow
`AdvanceOneTick` is the per-tick entry point for a train. The method follows the same structure as the existing `Update(double deltaTime)` implementation and will replace that name as the deterministic tick rollout lands.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L57-L105】

1. **Docking handling:** If the unit is auto-running and currently docked, the tick calls `TrainUnitStationDocking.TickDockedStations()` so every attached receiver processes exactly one docked-tick before any movement.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L61-L75】【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnitStationDocking.cs†L60-L71】 Docked trains are forced to zero speed during these ticks so they cannot drift while loading.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L65-L66】 When the diagram reports that departure conditions are met, the train updates its next destination and undocks in the same tick.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L68-L75】
2. **Movement preparation:** If not docked, the train refreshes its destination from the diagram (guarding against rails removed mid-run) and proceeds to the motion phase.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L79-L102】 Manual driving follows the same shape but without diagram advancement yet.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L84-L103】
3. **Velocity integration:** The tick uses `UpdateTrainByTime` to integrate acceleration, friction, and speed limits over the fixed \(1/120\) s delta. The method computes a floating-point travel distance, accumulates it in `_accumulatedDistance`, and truncates the integer part without any random sampling before handing it to `UpdateTrainByDistance`.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L123-L137】
4. **Segment traversal and docking:** `UpdateTrainByDistance` consumes the integer steps, advances along the rail graph, and when the destination node is reached it triggers `TryDockWhenStopped` to re-evaluate station alignment.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L140-L156】【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnitStationDocking.cs†L93-L147】 If movement stalls at a junction the train either recomputes the shortest path toward its destination or falls back to a random outgoing edge, ensuring that every tick resolves the same forked choice given the same `UnityEngine.Random` seed.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L168-L208】

## Docking and item transfer timeline
Docking runs on the same tick cadence. When `TryDockWhenStopped` succeeds the car registers with each station block via `TrainUnitStationDocking`, and subsequent ticks call `OnTrainDockedTick` on the receivers.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnitStationDocking.cs†L67-L138】 Station-style blocks (e.g., passenger stations and cargo platforms) iterate their inventories once per tick, pulling or pushing one stack at a time until capacity or supply is exhausted, which creates predictable per-tick throughput.【F:moorestech_server/Assets/Scripts/Game.Block/Blocks/TrainRail/StationComponent.cs†L57-L124】【F:moorestech_server/Assets/Scripts/Game.Block/Blocks/TrainRail/CargoplatformComponent.cs†L84-L190】 Because trains remain stationary while docked ticks execute, any departure condition (empty inventory, schedule fulfilled, manual override) is evaluated immediately after the same tick that performed the last transfer.

## Intentional sources of randomness
Intentional randomness is limited to fallback routing: when the pathfinder cannot produce a valid route (usually during manual driving on altered tracks), `UpdateTrainByDistance` chooses a random connected node to continue traversal, avoiding hard stalls while still respecting deterministic seeds in automated tests.【F:moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs†L168-L208】 Keep any additional randomness centralized so replay determinism only depends on the global Unity random state.
