---
name: debugging-workflow
description: >
  体系的ソフトウェアデバッグワークフロー。テストが失敗する時、実装が意図通りに動かない時、
  コンパイルエラーの原因が不明な時に使用する。
  Use when: (1) テストコードがパスしない時 (2) 実装が意図した動作をしない時
  (3) 原因不明のバグに遭遇した時 (4) 「デバッグして」「なぜ動かないか調べて」と言われた時
---

# Debug Workflow

体系的にバグの原因を特定し修正する。推測で修正せず、証拠に基づいて行動する。

## Step 1: 症状の正確な把握

修正に飛びつく前に、問題を正確に理解する。

- エラーメッセージ・スタックトレースを全文確認
- 期待される動作と実際の動作の差分を明確化
- 再現条件を特定（常に発生？特定条件のみ？）

```
【記録テンプレート】
期待: [期待される動作]
実際: [実際の動作]
エラー: [エラーメッセージ全文]
再現: [再現手順・条件]
```

## Step 2: 仮説の列挙（5-7個）

問題の原因として考えられる可能性を **5～7個** 列挙する。
幅広く考え、思い込みを排除する。

カテゴリ別に検討:
- **データ**: 入力値、マスターデータ、初期化順序
- **状態**: オブジェクトのライフサイクル、タイミング
- **依存**: 他システムとの連携、イベント順序
- **環境**: Unity固有の問題、非同期処理、スレッド

## Step 3: 絞り込み（1-2個）

列挙した仮説から **最も可能性の高い1～2個** に絞る。

判断基準:
- エラーメッセージとの整合性
- 変更履歴との関連（最近変更した箇所か）
- 再現パターンとの一致
- 過去の類似バグの経験

## Step 4: ログによる仮説検証

絞り込んだ仮説をデバッグログで検証する。推測で修正しない。

```csharp
// サーバー側
Debug.Log($"[DEBUG] {変数名}: {値}");

// クライアント側 (UniRx等の非同期フローの場合)
Debug.Log($"[DEBUG] {メソッド名} called at frame {Time.frameCount}, value={値}");
```

ログ配置の指針:
- 問題のメソッドの入口と出口
- 条件分岐の直前（判定に使う値を出力）
- データ変換の前後

## Step 5: 検証と修正

ログ結果から原因を特定し修正する。

- 仮説が正しければ → 最小限の修正を実施
- 仮説が外れたら → Step 2に戻り残りの仮説を検証、または新たな仮説を追加
- 修正後は必ずテストを再実行して確認

## Step 6: クリーンアップ

- デバッグ用ログをすべて削除
- 修正内容がプロジェクト全体の一貫性を保っているか確認

## アンチパターン

- **推測修正**: ログで確認せずに「たぶんここが原因」で修正する → 二次障害の温床
- **一度に大量変更**: 複数箇所を同時修正すると原因特定が困難になる
- **ログ残し**: デバッグログを残したままコミットする
