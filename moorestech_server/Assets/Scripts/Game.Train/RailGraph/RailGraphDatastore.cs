using System.Collections.Generic;
using System.Linq;
namespace Game.Train.RailGraph
{
    ///
    /// NodeId is a unique ID to identify the node
    ///
    public class RailGraphDatastore
    {
        private readonly Dictionary<RailNodeId, RailNode> _nodes = new();

        public RailGraphDatastore()
        {
        }

        
        public void AddNode(RailNode node)
        {
            _nodes[node.NodeId] = node;
        }

        public void RemoveNode(RailNodeId nodeId)
        {
            _nodes.Remove(nodeId);
        }



        /// <summary>
        /// ダイクストラ法を用いて開始ノードから目的地ノードまでの最短経路を計算します。
        /// generated by chat gpt o1
        /// ダイクストラ法で遅いようならAsterに変える予定
        /// 計算量はO(E + V log V)で、Eは辺の数、Vはノードの数。ただしDictionary クラス（ハッシュマップに基づくデータ構造）がアクセスや更新に対して平均計算量O(1)であるとする
        /// </summary>
        /// <param name="start">開始ノード</param>
        /// <param name="destination">目的地ノード</param>
        /// <returns>最短経路のノード順リスト</returns>
        public List<RailNode> FindShortestPath(RailNode start, RailNode destination)
        {
            // 優先度付きキュー（距離が小さい順）
            var priorityQueue = new PriorityQueue<RailNode, int>();

            // 各ノードへの最短距離を記録する辞書（初期値は無限大を表す int.MaxValue）
            var distances = new Dictionary<RailNode, int>();

            // 各ノードの前に訪れたノードを記録する辞書
            var previousNodes = new Dictionary<RailNode, RailNode>();

            // 全てのノードを初期化
            foreach (var node in _nodes.Values)
            {
                distances[node] = int.MaxValue;
                previousNodes[node] = null;
            }

            // 開始ノードの距離を0に設定し、優先度付きキューに追加
            distances[start] = 0;
            priorityQueue.Enqueue(start, 0);

            while (priorityQueue.Count > 0)
            {
                // 現在のノードを取得
                var currentNode = priorityQueue.Dequeue();

                // 目的地に到達したら終了
                if (currentNode == destination)
                {
                    break;
                }

                // 現在のノードからつながる全てのノードを確認
                foreach (var (neighbor, distance) in currentNode.ConnectedNodes)
                {
                    int newDistance = distances[currentNode] + distance;

                    // なにかの間違いでintがオーバーフローした場合(経路が長すぎたり)
                    if (newDistance < 0)
                        continue;
                    
                    // より短い距離が見つかった場合
                    if (newDistance < distances[neighbor])
                    {
                        distances[neighbor] = newDistance;
                        previousNodes[neighbor] = currentNode;

                        // キューに隣接ノードを追加または更新
                        priorityQueue.Enqueue(neighbor, newDistance);
                    }
                }
            }

            // 経路を逆順でたどる
            var path = new List<RailNode>();
            var current = destination;
            while (current != null)
            {
                path.Add(current);
                current = previousNodes[current];
            }

            // 開始ノードまでたどり着けなかった場合は空のリストを返す
            if (path.Last() != start)
            {
                return new List<RailNode>();
            }

            // 経路を正しい順序に並べて返す
            path.Reverse();
            return path;
        }

    }
}
